use codemap_diagnostic::{ColorConfig, Diagnostic, Emitter, Level};
use std::{
    env,
    fs::File,
    io::prelude::*,
    path::{Path, PathBuf},
};

mod diag;
mod parser;

pub struct BuildScriptConfig {
    in_root_source_file: Option<PathBuf>,
    out_source_file: Option<PathBuf>,
}

impl Default for BuildScriptConfig {
    fn default() -> Self {
        Self::new()
    }
}

impl BuildScriptConfig {
    pub fn new() -> Self {
        Self {
            in_root_source_file: None,
            out_source_file: None,
        }
    }

    pub fn root_source_file(self, path: impl AsRef<Path>) -> Self {
        Self {
            in_root_source_file: Some(path.as_ref().to_path_buf()),
            ..self
        }
    }

    pub fn out_source_file(self, path: impl AsRef<Path>) -> Self {
        Self {
            out_source_file: Some(path.as_ref().to_path_buf()),
            ..self
        }
    }

    pub fn run_and_exit_on_error(self) {
        if self.run().is_err() {
            std::process::exit(1);
        }
    }

    pub fn run(self) -> Result<(), ()> {
        let result = self.run_inner();
        if let Err(e) = result {
            if let Some(message) = e {
                let mut emitter = Emitter::stderr(ColorConfig::Auto, None);
                emitter.emit(&[Diagnostic {
                    level: Level::Error,
                    message,
                    code: None,
                    spans: vec![],
                }]);
            } else {
                // The error is already reported to stderr if `e` is `None`
            }

            Err(())
        } else {
            Ok(())
        }
    }

    fn run_inner(self) -> Result<(), Option<String>> {
        let in_root_source_file = if let Some(x) = self.in_root_source_file {
            x
        } else {
            let dir = env::var_os("CARGO_MANIFEST_DIR").ok_or(
                "CARGO_MANIFEST_DIR is missing; are we really in a build script?".to_string(),
            )?;
            let path = Path::new(&dir).join("lib.tcwdl");
            path
        };

        let out_source_file = if let Some(x) = self.out_source_file {
            x
        } else {
            let out_dir = env::var_os("OUT_DIR")
                .ok_or("OUT_DIR is missing; are we really in a build script?".to_string())?;
            let dest_path = Path::new(&out_dir).join("designer.rs");
            dest_path
        };

        let mut diag = diag::Diag::new();

        let root_source = diag
            .load_file(&in_root_source_file, None)
            .map_err(|()| None)?;

        let _root_file = parser::parse_file(&root_source, &mut diag).map_err(|()| None)?;

        let mut out_f = File::create(&out_source_file).map_err(|e| {
            format!(
                "Could not open the output file '{}': {}",
                out_source_file.display(),
                e
            )
        })?;

        out_f
            .write_all(
                b"
            /// Automatically generated by `tcw3_designer`.
            pub static DESIGNER_METADATA: &[u8] = &[];

            #[macro_export]
            macro_rules! designed_impl {
                () => ();
            }
        ",
            )
            .map_err(|e| {
                format!(
                    "I/O error while writing the output file '{}': {}",
                    out_source_file.display(),
                    e
                )
            })?;

        if diag.has_error() {
            Err(None)
        } else {
            Ok(())
        }
    }
}
