//! Implements the code generation of doc comments.
use proc_macro2::Span;
use quote::ToTokens;
use std::{fmt, fmt::Write};

use super::super::{diag::Diag, sem::DocAttr};
use super::Concat;

/// Generates a doc comment attribute with string formatting. Evaluates to
/// a value of type `Doc`, which implements `Display`.
macro_rules! doc_attr {
    ($($args:tt)*) => {
        $crate::codegen::implgen::docgen::Doc(format_args!($($args)*))
    };
}

/// `#[doc = "{0}"]`
#[derive(Clone, Copy)]
pub struct Doc<T>(pub T);
impl<T: fmt::Display> fmt::Display for Doc<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let lit = syn::LitStr::new(&self.0.to_string(), Span::call_site());
        write!(f, "#[doc = {}]", lit.to_token_stream())
    }
}

/// ``... `code` ...``
#[derive(Clone, Copy)]
pub struct MdCode<T>(pub T);
impl<T: fmt::Display> fmt::Display for MdCode<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let inner = self.0.to_string();

        if inner.is_empty() {
            return write!(f, "` `");
        }

        let pre = &" "[..inner.starts_with('`') as usize];
        let post = &" "[..inner.ends_with('`') as usize];

        // Find out the maximum number of consecutive backticks in the string
        let max_num_backticks = inner
            .bytes()
            .fold((0, 0), |(max_len, cur_len), b| {
                let cur_len = if b == b'`' { cur_len + 1 } else { 0 };
                (std::cmp::max(max_len, cur_len), cur_len)
            })
            .0;

        let wrap = Concat(std::iter::repeat('`').take(max_num_backticks + 1));

        write!(
            f,
            "{wrap}{pre}{inner}{post}{wrap}",
            wrap = wrap,
            pre = pre,
            inner = inner,
            post = post
        )
    }
}

/// `#[doc = "*Automatically generated by TCW3 Designer. Defined at ...*"]`
#[derive(Clone, Copy)]
pub struct CodegenInfoDoc<'a, 'b>(pub Option<codemap::Pos>, pub &'a Diag<'b>);
impl fmt::Display for CodegenInfoDoc<'_, '_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if let Some(pos) = self.0 {
            let loc = self.1.look_up_pos(pos);
            write!(
                f,
                "{}",
                doc_attr!(
                    "*Automatically generated by TCW3 Designer. \
                     Defined at line {} of file {}.*",
                    loc.line + 1,
                    MdCode(loc.name),
                )
            )
        } else {
            write!(
                f,
                "{}",
                doc_attr!("*Automatically generated by TCW3 Designer.*")
            )
        }
    }
}

pub fn gen_doc_attrs(attrs: &[DocAttr], indent: &str, out: &mut String) {
    for attr in attrs {
        writeln!(out, "{}{}", indent, Doc(&attr.text)).unwrap();
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn doc_attr() {
        assert_eq!("#[doc = \"1 = 2\"]", doc_attr!("{} = {}", 1, 2).to_string());
    }

    #[test]
    fn md_code() {
        assert_eq!("` `", MdCode("").to_string());
        assert_eq!("`42`", MdCode("42").to_string());
        assert_eq!("`` `horse``", MdCode("`horse").to_string());
        assert_eq!("``horse` ``", MdCode("horse`").to_string());
        assert_eq!("`` `horse` ``", MdCode("`horse`").to_string());
        assert_eq!("```` ``` ````", MdCode("```").to_string());
    }
}
